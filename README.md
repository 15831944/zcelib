
#ZCELIB 


**ZCELIB**是我无聊开发的一套类库,很多代码都是若干年前的了.代码的开发大部分利用的一些闲暇时间，当然我希望以后他能开源。
其实很多代码可以用其他的库代替,但是他们有些不是太大就是太笨重.一个
轻巧的功能何必用数十万行代码实现?代码只考虑两个平台的通用,Windows(x86,x64)下的Visual C++,
(.NET) 和Linux下的GCC.虽然我相信跨越其他平台也不是难事,但是
那不是我写这套代码的目的.

##为什么取名ZCE LIB？
这个问题其实很难回答，ZEN Communication Environment
大家如果有兴趣看过3D版本肉蒲团的英文名称就知道了，ZEN & SEX，
其实如果说完全和自己无关那是骗人，但主要原因仍然是ZEN是禅的意思。TAO是道，期望自己的库名字有感觉一点。


##2.造轮子的故事和我喜欢的C++
我不是一个非常喜欢造轮子的人,但我也忍受不了很多很臭的袜子。
我对于类库是非常挑剔的.简单,优美,稳定,效率高,C++对象化的我才看得上眼.
STL(STLPort),ACE,Boost,才是我看得上的类库.如果一个库实在违反我的代码美学,我宁愿自己写一个.

C++ 是难学易用的东西,不过我建议你掌握.可惜大部分的自称C++的程序员只停留在认为C++是带类的C的阶段

对于说STL,效率低的人,我报以同情.建议你把认为效率低的代码给我重写一下.赫赫.
STL(SGI)那是世界上最聪明的几个脑瓜程序员实现的东西,诬蔑之前掂量一下.

而对于网络和系统API等,
我最开始就没打算尝试,ACE是这个方面的泰斗.我只有顶礼膜拜的份.
但最后，我还是自己实现了一套。有很多时候我就是不断的自我否定，

##3.比较完善的功能列表
- OS         OS适配层，为了适应WINDOWS和LINUX两个环境的代码增加的一层，基本可以替代ACE了。
- C STRING   的一些函数,用于某些特殊环境,
- INI        INI文件的读写,实现的功能和Win32的API类似,不过也就是因为想和他的API类似,把代码搞复杂了.
- DEBUG      调试库,提供完善的调试方法,VC在这方面很强,偷学了一些.
- LOG        日志库,用于记录日志,可以定义分割日志的方式等(大小,日期),日志可以定级输出.
- MySQL      一套接口库,封装模型和各种通用接口类似,完整和方便是这个库最大的好处.我甚至封装了STMT.前卫把.
- MMAP       操作库,包括一些类似STL的模版,
- IDTOSTRING 的一套宏,自认为写的还是比较精巧的.
- CGI        使用一个模板输出网页,我推荐你使用CCGI的库,GNU出品的,但是他的没有一个使用模板的分装.我自己写了一个.但是推广失败.自己
感觉比公司TLIB的使用方式方便不是1点半点.看来习惯的东西要命.
- SERVERKIT  服务器的工具类，目前提供了一个使用MMAP的状态统计类。
- PIDFILE    防止服务器多次启动的PID文件类，很有意思，发现UNIX通信卷2也讲过这些东西。土呀，还是土呀。
- NET        最后还是去掉了ACE的部分代码，所以还是被迫自己实现了一个网络层。
- TIME       时间和定时器，原来打算只用Time value，结果发现


对于MMAP STL的一些代码,我封装他们纯属无奈,其实我不认为使用MMAP有多大好处.
我喜欢线程和普通内存,但是如果使用多进程的模型,而且要有一个持久存储时,你就必须用共享内存.
而几乎所有的容器模板(包括ACE的)都使用了指针,而指针这种东西对于共享内存又是天敌.
不过也好,可以通过写这些东西,彻底理解STL.
(虽然我认定多线程的代码可以美丽优雅,决不逊色于多进程的各种模型,但是持久存储那是一堵墙)
(持久存储也许是一个好看但并不太实用的东西,恢复现场可能会有无数的问题.小心)

##4.
对于DEBUG和日志类,
我很难说封装的好坏.我最后还是将日志和调试类结合到一起了.原来我讨厌这个做法,
但是看ACE的代码多了,我也习惯了.
为什么不用ACE的LOG?
原因有两个,ACE的日志不提供按日期分隔日志的方式.而这是我最喜欢的分割日志的方式.
另外,ACE日志要最舒服的使用必须用到服务模型,但是我不打算一定要用他的服务模型.
我将调试使用的宏,和日志的宏分开,调试的宏还是可以在非DEBUG版本屏蔽掉的.
最大满足你对速度得渴望.如果你不理解,建议去读读VC++的调试部分代码.
另外ACE的日志必须用REACTOR,不是所有的环境都回用这个咚咚。
不过最后我还是提供了一个ACE的日志策略类，因为讨厌多线程。我提供了足够的灵活度。

CGI  使用一个模板输出网页,
对于CGI的类库,我推荐你使用CCGI的库,GNU出品的,质量的保障,C++的作品,比公司内部用的那个库TLIB强了也不是一点半点.
但是他的没有一个使用模板的分装.我自己写了一个.但是推广失败.
自己感觉比公司TLIB的使用方式方便也不是一点半点.顺序输出思维,完全避免了字符转换的痛苦,,还可以自己选择输出对象,看来习惯的东西要命.
以后再封装1个类似TLIB的吧.

IDTOSTRING 用过MFC的LoadString吧,我就是要实现它.
我不用资源文件也实现了它,就是用宏.<MFC深入浅出>中对宏的运用让我惊叹.我这儿只是偷师一下.
代码中无数的返回值,而不知道他们的意义.这个东西就是搭救你的.


##修改记录，应该说是ZCELIB日记
- 20060101
越来越和该死的进程，线程打交道,感觉要放弃原来考虑的不合ACE打交道
如果是一个的后台的库,不用ACE感觉基本不可能。犹豫

- 20060102
今天感觉日志类不完善,没有线程部分保护的东西,由于内部有自己的缓冲去,在多线程的情况下
肯定会出现问题，
去看了看ACE的策略日志类，也就研究了一下ACE的日志部分。
感觉ACE的封装也一般般,日志策略全部使用命令行作为初始化方式,我没有这个爱好
另外所有的时间戳也是调用API得到的,这个这个，其实查询时间的API是个不是个高效操作.
kingwang的评价有道理,ace压根就没想非常高效。只是一般高效。呵呵
不过还是按照自己的感觉封装一个ACE的日志策略类,
完了,既然打算用ACE，就抛弃那些自己写的跨平台的代码把。


- 20060315
看了C4A的服务器统计类，(rong,sonicmao)觉得是一个非常好的想法，所以偷师了。

- 20060610
加入了一个MYSQLProcess类,其实这个封装我的相当多的代码用过,不过为了在CGI的代码中间
偷懒,我都是每个LIB写一个类似的,
这次完整的封装一下,以后要改变写类似代码的习惯.
另外,决定将代码统一改为ACE UNIX风格.和bolanfan PK了一下午,虽然我们俩说的问题都是不是一个层面,
我还是认可统一规范的重要的,

- 20070904
好久没有改这个库了，前不久加入了一个PID文件的输出类，加了文件锁。终于看完了UNIX的记录锁
。也算有点收获，小小进步一下。

- 20110320
决定重构这个库，打算摆脱ACE，一方面是liangfeng不喜欢，一方面是我自己也觉得ACE有点重了，
本来打算投奔Boost，但是使用Boost的过程发现Boost离我心中的目标还非常遥远，我只有放弃了。
所以改动很多，包括增加OS适配层，重新改写日志模块，重新整理了大量代码。

- 20111030
大规模改写代码大致完成，改写断断续续，中间耗费时间持续了大约2个月，大部分是周末时间，特别是那个苦难的10.1长假，
但是bug还是很多，yunfeiyang，liangfeng,stevzhou,erray，佐助，等朋友都帮我修改了这套库，感谢他们帮我调试

- 2012年5月7日
修改了所有的卫哨定义。

- 2012年6月
zen_server_status监控的代码进行了改写，不再使用数组ID作为监控下标，而使用hash table作为idx，性能有所降低，
但兼容性要好很多。
djiang PK胜利。

- 201208
对于原来的依靠模版完成GUARD功能进行了反思，增加利用OO完成的锁功能。

- 20120920
这一年都在小规模的改写这个库，原来约有点味道了，至少像那么回事了。
9月BB出世，在陪产假期继续完善了一下库。改写部分Mutex部分，增加了一些新代码，比如SPIN的锁，Process的几个锁的封装。
增加了IPV6的支持，（虽然增加了，不知道什么时候才能测试）
增加了一些域名相关的代码。
增加了SYSTEM V的共享内存的跨平台支持，

- 201210
增加了random的代码。
增加了uuid的代码

- 20121108
今天中国著名的斯巴达召开了。哦喔喔。
增加了一些读取本机配置性能，进程性能的代码。
这些代码会增加我们监控的效果。
pascalshen帮助我修正了很多错误。

- 20130101
不再和原来公司的代码同步，保持自己的代码的唯一性。
主要为了避免未知的版权风险，把代码彻底独立独立出来，改名，


##6.必须感谢的人，排名不分先后，
先后有很多兄弟们帮助我完善了这个库，特别是11年的改写后，由于时间不足，大量的测试工作是他们完成的。
- scottxu, 很早贡献过一套共享内存红黑树代码
- inmoreliu,linkerlin，帮助打过酱油，
- sonicmao，rong，他们的很多代码我都参考过。
- chrislin，贡献过很多类似boost的代码
- chweiling，errayzhao，djiang，liangfeng，sasukeliu，stefzhou，yunfeiyang，pascalshen平台开发组的兄弟们，2011年的版本他们贡献良多，
- yunfeiyang 在2011-2012一段时间一直在帮忙增加代码和帮忙改写我这个流氓种下的bug，
- sriverxiao 帮我测试过多节hash


##7
以下是《Learn Python The Hard Way, 2nd Edition》这本书的尾声部分。
看完了这本书，你决定继续做编程。也许它能成为你的一个职业，也许它能成为你的一项爱好。但你需要一些指导，确保自己不会走错了道路，或帮助你从这个新业余爱好中得到最大的乐趣。
我做了很久的编程。久的你都想象不出来，久的都让我苦恼。就在我写这本书的时候，我大概懂20种编程语言，而且我可以用一天或长点儿用一周的时间学会一种新语言——要依这种语言有多奇怪而定。但这最终成为了我的苦恼，它们已经不能再吸引我的兴趣。我并不是说这些语言没有意思，或告诉你你会觉得它们很枯燥。只是想说在我的职业旅程走到现在，我已不再对语言有兴趣。
经过这么多年的学习经历，我发现语言本身并不重要，重要的是你如何用它们。事实上，我一直知道这个道理，但我总是被语言吸引走，周期性的忘记这个道理。现在我不再忘记了，你也应该这样。
你会什么语言、你用什么语言，这并不重要。不要被围绕在编程语言周围的各种宗教宣传迷惑，那些只会遮蔽你的眼睛，让你看不出这些语言只是一种让你做有趣的事情的工具而已。这才是它们的真正属性。
编程作为一种智力活动，它是唯一的一种能让你创造出交互式艺术作品的艺术形式。你创造出来人们可以操作的软件，你是在间接的和人们交互。没有任何其它艺术形式有如此的交互性。电影是单向的向观众传输信息。绘画是静态的。而软件程序却是双向动态的。
编程只能算是一项一般有趣的工作。它可以成为一个不错的职业，但如果你既想多挣钱又要干的高兴，不如去开一家快餐馆。如果你把编程当做一种秘密武器在其它行业里使用，也许会有更好的效果。
科技界科技公司里会编程的人多如牛毛，没人会在意他们。而在生物界，医药界，政府，社会学界，物理界，历史界和数学界，如果你有这种技能，你能做出令人瞩目的事情。
当然，所有的这些话都是没有意义的。如果通过这本书，你喜欢上了编程，你应该尽你最大的努力，通过它来改善你的生活。去探索这神奇的精彩的智力活动，也只有近50年来的人有机会从事这种职业。如果你喜欢它，就尽情的热爱它吧。
最后我要说的是，学习开发软件会改变你，让你与众不同。不论是好的不同还是坏的，反正是不同。你会发现，因为你会开发软件，人们会对你很冷淡，会用“书呆子”这样的词形容你。你会发现，由于你善于剖析逻辑，人们痛恨跟你辩论。你甚至会发现，只是简单的懂一些计算机原理都会给你带来很多烦恼，让你跟他们比起来怪怪的。
对于这些问题，我只有一点小建议：让他们去死吧。这世界需要更多的能知道事情如何工作、喜欢去探索的人。当他们这样对待你时，你要记住，这是你的生活，不是他们的。与众不同不是罪恶，人们这样对你只是出于嫉妒，嫉妒你拥有一项他们在梦中都无法拥有的技能。
你会编程。他们不会。这真他妈的酷毙了。

